local GRID_SIZE = 16
local MOVE_SPEED = 0.2

-- Предполагаем, что у вас есть тайлмап с такими ID слоев
local LAYER_WALLS = hash("walls") -- Неразрушимые стены
local LAYER_BRICKS = hash("bricks") -- Разрушаемые стены

function init(self)
--	msg.post("@system:", "toggle_physics_debug")
	msg.post(".", "acquire_input_focus")
	self.is_moving = false
	-- Храним текущее направление ввода
	self.input_dir = vmath.vector3(0, 0, 0)
	-- Ссылка на тайлмап (путь к компоненту)
	self.tilemap_url = "level_manager#template" 
end

-- Функция проверки: можно ли наступить в клетку?
local function can_move_to(self, target_pos)
	-- Переводим пиксельные координаты в координаты сетки тайлмапа (1-based)
	local x = math.floor(target_pos.x / GRID_SIZE) + 1
	local y = math.floor(target_pos.y / GRID_SIZE) + 1

	-- Получаем ID тайла в слоях стен
	local wall_tile = tilemap.get_tile(self.tilemap_url, LAYER_WALLS, x, y)
	local brick_tile = tilemap.get_tile(self.tilemap_url, LAYER_BRICKS, x, y)

	-- Если ID тайла равен 0, значит там пусто
	return wall_tile == 0 and brick_tile == 0
end

-- Внутри player.script изменим логику перемещения

local function move_to_cell(self, direction)
	if self.is_moving or vmath.length(direction) == 0 then return end

	local current_pos = go.get_position()
	local target_pos = current_pos + (direction * GRID_SIZE)

	-- 1. Сначала проверяем статические стены тайлмапа
	if not can_move_to(self, target_pos) then return end

	-- 2. Проверяем, нет ли там динамического объекта (Динамит/Коробка)
	-- В Defold для этого удобно использовать raycast или хранить таблицу позиций.
	-- Для MVP используем простой физический запрос:
	local ray_hit = physics.raycast(current_pos, target_pos, {hash("box"), hash("dynamite"), hash("bombs")})

	if ray_hit then
		-- Если уперлись в объект — пробуем его толкнуть
		self.pending_target_pos = target_pos -- Запоминаем, куда хотели идти
		msg.post(ray_hit.id, "push", { direction = direction })
		-- Мы не идем сами, пока объект не ответит "push_success"
		return 
	end

	-- 3. Если путь совсем пуст — просто идем
	self.is_moving = true
	go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, target_pos, go.EASING_LINEAR, MOVE_SPEED, 0, function()
		self.is_moving = false
	end)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("push_success") then
		-- Если объект впереди успешно сдвинулся, игрок шагает на его место
		self.is_moving = true
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, self.pending_target_pos, go.EASING_LINEAR, MOVE_SPEED, 0, function()
			self.is_moving = false
		end)
	end
	if message_id == hash("move") then
		self.move_dir = message.direction
		self.move_ratio = message.ratio
	end

	if message_id == hash("plant_bomb") then
		local pos = go.get_position()
		-- Привязываем к сетке
		print(pos.x)
		pos.x = math.floor(pos.x / GRID_SIZE) * GRID_SIZE + GRID_SIZE/2
		print(pos.x)
		pos.y = math.floor(pos.y / GRID_SIZE) * GRID_SIZE+ GRID_SIZE/2
		factory.create("#bomb_factory", pos)
	end
	
end

function update(self, dt)
	if not self.is_moving then
		-- Выбираем приоритетную ось. 
		-- Если нажаты обе, сначала проверяем движение по горизонтали, затем по вертикали.
		local move_dir = vmath.vector3(0, 0, 0)

		if self.input_dir.x ~= 0 then
			move_dir.x = self.input_dir.x
		elseif self.input_dir.y ~= 0 then
			move_dir.y = self.input_dir.y
		end

		if vmath.length(move_dir) > 0 then
			move_to_cell(self, move_dir)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("key-up") then
		self.input_dir.y = action.released and 0 or 1
	elseif action_id == hash("key-down") then
		self.input_dir.y = action.released and 0 or -1
	elseif action_id == hash("key-left") then
		self.input_dir.x = action.released and 0 or -1
	elseif action_id == hash("key-right") then
		self.input_dir.x = action.released and 0 or 1

		-- Бомба
	elseif action_id == hash("key-space") and action.pressed then
		-- Логика спавна бомбы будет тут
		local pos = go.get_position()
		-- Привязываем к сетке
		print(pos.x)
		pos.x = math.floor(pos.x / GRID_SIZE) * GRID_SIZE + GRID_SIZE/2
		print(pos.x)
		pos.y = math.floor(pos.y / GRID_SIZE) * GRID_SIZE+ GRID_SIZE/2
		factory.create("#bomb_factory", pos)
	end
end