local CONFIG = require "main.game_config"

local MOVE_SPEED = 0.2

-- Функция должна быть объявлена ДО того, как она вызывается в on_message
local function move_next(self)
	-- Проверка: есть ли путь и не дошли ли мы до конца
	if not self.path or self.current_step > #self.path then 
		-- Путь окончен. Проверяем, где мы.
		local current_pos = go.get_position()
		local cur_x = math.floor(current_pos.x / 16)
		local cur_y = math.floor(current_pos.y / 16)

		if cur_x == self.final_target_x and cur_y == self.final_target_y then
			print("УРА! Мы у выхода!")
			--msg.post("/level_manager#level_manager", "reached_exit")
		else
			print("ПУТЬ ПРЕГРАЖДЕН! Я дошел максимально близко.")
			-- Тут можно вывести GUI сообщение "Путь заблокирован кирпичами!"
		end

		self.path = nil
		return 
	end

	local step = self.path[self.current_step]
	-- Центрируем игрока в клетке (+8)
	local target_pos = vmath.vector3(step.x * CONFIG.GRID_SIZE + 8, step.y * CONFIG.GRID_SIZE + 8, 1)

	print("PLAYER: Шагаю в клетку", step.x, step.y)

	go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, target_pos, go.EASING_LINEAR, MOVE_SPEED, 0, function()
		self.current_step = self.current_step + 1
		move_next(self) -- Рекурсивный вызов следующего шага
	end)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.is_moving = false
	self.path = nil
	self.current_step = 1
end

function on_message(self, message_id, message, sender)
	if message_id == hash("follow_path") then
		self.path = message.path
		self.current_step = 1
		-- Запоминаем, куда мы В ИДЕАЛЕ хотели попасть
		self.final_target_x = message.target_x
		self.final_target_y = message.target_y
		move_next(self)
	elseif message_id == hash("take_damage") then
		print("Player is dying")
		go.delete()
	end
	
end

function on_input(self, action_id, action)
	if action_id == hash("space") and action.pressed then
		print("1. Нажат Пробел!") -- Если этого нет в консоли, проблема во вводе
		msg.post("level_manager#level_manager", "move_to_exit")
	end
end