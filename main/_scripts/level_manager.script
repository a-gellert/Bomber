local levels = require "main.levels"
local CONFIG = require "main.game_config"
local pathfinder = require "main.pathfinder"

local LAYER_WALLS = hash("walls")
local LAYER_BRICKS = hash("bricks")
local GRID_SIZE = CONFIG.GRID_SIZE

-- 1. Сетка и занятость
local function set_cell_occupied(self, tx, ty, occupied)
	if not self.grid[tx] then self.grid[tx] = {} end
	self.grid[tx][ty] = occupied
end

local function is_cell_empty(self, x, y)
	local tx = math.floor(x / GRID_SIZE)
	local ty = math.floor(y / GRID_SIZE)
	if self.grid[tx] and self.grid[tx][ty] then
		return false
	end
	return true
end

-- 2. Очистка уровня
local function clear_level(self)
	for _, id in ipairs(self.spawned_objects) do
		if go.exists(id) then go.delete(id) end
	end
	self.spawned_objects = {}
	self.grid = {} 

	local x, y, w, h = tilemap.get_bounds("#template")
	if w > 0 and h > 0 then
		for tx = x, x + w - 1 do
			for ty = y, y + h - 1 do
				tilemap.set_tile("#template", LAYER_WALLS, tx, ty, 0)
				tilemap.set_tile("#template", LAYER_BRICKS, tx, ty, 0)
			end
		end
	end
end

-- 3. Загрузка уровня
local function load_level(self, level_id)
	local level_data = levels.schemes[level_id]
	if not level_data then 
		print("Уровень " .. level_id .. " не найден!") 
		return 
	end

	-- Poki SDK: Gameplay Start
	if poki_sdk then poki_sdk.gameplay_start() end

	clear_level(self)

	local layout = level_data.layout
	self.bombs_left = level_data.bombs or 1
	-- Обновляем GUI сразу после загрузки
	msg.post("level_gui#level_results.gui", "update_bombs", { count = self.bombs_left })

	print("Загрузка уровня: " .. level_id .. " | Бомб: " .. self.bombs_left)

	local height = #layout
	for y, row in ipairs(layout) do
		local map_y = height - y + 1 
		for x = 1, #row do
			local char = string.sub(row, x, x)
			local pos = vmath.vector3((x - 1) * GRID_SIZE + GRID_SIZE/2, (map_y - 1) * GRID_SIZE + GRID_SIZE/2, 0)

			if char == "W" then
				tilemap.set_tile("#template", LAYER_WALLS, x, map_y, 376)
				set_cell_occupied(self, x - 1, map_y - 1, "W")
			elseif char == "B" then
				tilemap.set_tile("#template", LAYER_BRICKS, x, map_y, 52)
				set_cell_occupied(self, x - 1, map_y - 1, "B")
			elseif char == "P" then
				self.player_id = factory.create("#player_factory", vmath.vector3(pos.x, pos.y, 1))
				table.insert(self.spawned_objects, self.player_id)
			elseif char == "X" then
				self.exit_id = factory.create("#exit_factory", vmath.vector3(pos.x, pos.y, 0.5))
				table.insert(self.spawned_objects, self.exit_id)
			elseif char == "M" then
				local id = factory.create("#mine_factory", vmath.vector3(pos.x, pos.y, 0.4))
				table.insert(self.spawned_objects, id)
				set_cell_occupied(self, x - 1, map_y - 1, "M")
			elseif char == "D" or char == "F" or char == "G" then
				local p = (char == "F" and 2) or (char == "G" and 3) or 1
				local id = factory.create("#dynamite_factory", vmath.vector3(pos.x, pos.y, 0.4), nil, { power = p })
				set_cell_occupied(self, x - 1, map_y - 1, "D")
				table.insert(self.spawned_objects, id)
			elseif char >= "1" and char <= "4" then
				local id = factory.create("#enemy_factory", vmath.vector3(pos.x, pos.y, 0.8), nil, { ai_type = tonumber(char) })
				table.insert(self.spawned_objects, id)
			end
		end
	end
end

function init(self)
	self.spawned_objects = {}
	self.grid = {}
	self.current_level = 1
	self.player_id = nil
	self.exit_id = nil
	self.bombs_left = 0

	timer.delay(0.1, false, function() load_level(self, self.current_level) end)
	self.start_time = socket.gettime()
end

function on_message(self, message_id, message, sender)
	-- УСТАНОВКА БОМБЫ
	if message_id == hash("try_place_bomb") then
		if self.bombs_left > 0 then
			local exp_pos = CONFIG.snap_to_grid(message.pos.x, message.pos.y)
			if is_cell_empty(self, exp_pos.x, exp_pos.y) then
				local bomb_id = factory.create("#bomb_factory", vmath.vector3(exp_pos.x, exp_pos.y, 0.5))
				table.insert(self.spawned_objects, bomb_id)
				set_cell_occupied(self, exp_pos.x, exp_pos.y, "D")

				self.bombs_left = self.bombs_left - 1
				msg.post("level_gui#level_results.gui", "update_bombs", { count = self.bombs_left })
			end
		end

		-- ДВИЖЕНИЕ К ВЫХОДУ
	elseif message_id == hash("move_to_exit") then
		if self.player_id and self.exit_id then
			-- Логика A* поиска пути (как в твоем исходнике)
			local p_pos = go.get_position(self.player_id)
			local e_pos = go.get_position(self.exit_id)
			local start_x, start_y = math.floor(p_pos.x/GRID_SIZE), math.floor(p_pos.y/GRID_SIZE)
			local end_x, end_y = math.floor(e_pos.x/GRID_SIZE), math.floor(e_pos.y/GRID_SIZE)

			local path = pathfinder.find_path(start_x, start_y, end_x, end_y, self.grid)
			if path then
				msg.post(self.player_id, "follow_path", { path = path, target_x = end_x, target_y = end_y })
				-- Включаем режим погони для врагов
				for _, id in ipairs(self.spawned_objects) do
					msg.post(id, "start_chase", { target_id = self.player_id })
				end
			end
		end

	elseif message_id == hash("reached_exit") then
		if poki_sdk then poki_sdk.gameplay_stop() end
		local play_time = socket.gettime() - self.start_time
		local stars = (play_time < 20 and 3) or (play_time < 40 and 2) or 1
		msg.post("level_gui#level_results.gui", "show_results", { stars = stars })

	elseif message_id == hash("next_level") then
		self.current_level = self.current_level + 1
		load_level(self, self.current_level)

	elseif message_id == hash("restart_level") then
		if poki_sdk then poki_sdk.gameplay_stop() end
		load_level(self, self.current_level)

	elseif message_id == hash("free_cell") then
		if self.grid[message.x] then
			self.grid[message.x][message.y] = nil
		end
	end
end